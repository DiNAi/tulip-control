.. highlight:: rst

Tutorial and Examples
=======================

The rhtlp is developed for synthesis of embedded control systems,
allowing planning to be done in a receding horizon manner.
For more information regarding the theory behind this, please visit
our `wiki <http://www.cds.caltech.edu/~utopcu/index.php/Receding_Horizon_Temporal_Logic_Planning_Toolbox_(RHTLP)>`_.


Synthesis of Embedded Control Systems
-------------------------------------
We consider a system that comprises the physical component, which we refer to as 
the plant, and the (potentially dynamic and not a priori known) environment in 
which the plant operates. 
The system may contain both continuous (physical) and discrete (computational)
components.
In summary, the problem we are interested in consists of

  - discrete system state,
  - continuous system state,
  - (discrete) environment state, and
  - specification.

Here, `discrete` state refer to the state that can take only a finite number
of possible values while
`continuous` state refer to the state that can take an infinite number
of possible values, e.g., the position of the car.
The `environment` state is related to factors over which the system does not 
have control such as the position of an obstacle and the outside temperature.
At any given time, the controller regulates the `system` (or `controlled`) 
state such that the specification is satisfied, given the current value of the 
environment variables and the previous system states.
We say that the specification is `realizable` if for any possible behavior
of the environment, such a controller exists, i.e., there exists a strategy
for the system to satisfy the specification.

Suppose the continuous state of the system evolves according to the
following discrete-time linear time-invariant state space model:
for :math:`t \in \{0,1,2,...\}`

.. math::
   s[t+1]  &=   As[t] + Bu[t] + Ed[t] \\
   u[t]    &\in U\\
   d[t]    &\in D\\
   s[0]	   &\in S
   :label: dynamics

where :math:`S \subseteq \mathbb{R}^n` is the state space of the continuous 
component of the system, 
:math:`U \subseteq \mathbb{R}^m` is the set of admissible control inputs, 
:math:`D \subseteq \mathbb{R}^p` is the set of exogenous disturbances and
:math:`s[t], u[t], d[t]` are the continuous state, the control signal and
the exogenous disturbance, respectively, at time :math:`t`.

We consider the case where the sets :math:`S, U, D` are bounded polytopes.

Let :math:`\Pi` be a finite set of atomic propositions of system variables.
Each of the atomic propositions in :math:`\Pi` essentially captures the
states of interest.
We consider the specification of the form

.. math::
   \varphi = \big(\varphi_{init} \wedge \varphi_e) \implies \varphi_s.
   :label: spec

Here, the assumption :math:`\varphi_{init}` on the initial condition of the system
is a propositional formula built from :math:`\Pi.`
The assumption :math:`\varphi_e` on the environment and the desired behavior 
:math:`\varphi_s` are LTL formulas built from :math:`\Pi.`
See our `wiki <http://www.cds.caltech.edu/~utopcu/index.php/Receding_Horizon_Temporal_Logic_Planning_Toolbox_(RHTLP)>`_ for more details on the form of :math:`\varphi_e, \varphi_s`.


.. image:: ecssyn.*

As illustrated in the figure above, our approach to this embedded control 
system synthesis consists of the following main steps:

   1. :ref:`Generate a proposition preserving partition of the continuous state space. <ssec:prop-part>`
   2. :ref:`Discretize the continuous state space based on the evolution of the continuous state. <ssec:disc>`
   3. :ref:`Digital design synthesis. <ssec:syn>`


.. _ssec:prop-part:

Proposition Preserving Partition of Continuous State Space
``````````````````````````````````````````````````````````
Given the continuous state space :math:`S` of the system and the set :math:`\Pi_c` of 
propositions on the continuous state of the system, we partition :math:`S` into a finite 
number of cells such that all the continuous states in each cell satisfy exactly the 
same set of propositions in :math:`\Pi_c`. 

This can be done using the following function call:

      .. autofunction:: prop2part.prop2part2


.. _ssec:disc:

Continuous state space discretization
`````````````````````````````````````
Given a propositional preserving partition of the continuous state space and
the evolution of the continuous state as in :eq:`dynamics`,
we refine the partition based on the reachability relation between cells
and obtain a finite state abstraction of the evolution of the continuous state, 
represented by a finite transition system.

This can be done using the following function call:


.. _ssec:syn:

Digital design synthesis
````````````````````````

The continuous state space discretization generates a finite state abstraction
of the continuous state, represented by a finite transition system.
Each state in this finite transition system corresponds to a cell in the continuous
domain.
A transition :math:`c_i \to c_j` in this finite state system indicates that 
from any continuous state :math:`s_0` that belongs to cell :math:`c_i`, 
there exists a sequence of control inputs :math:`u_0, u_1, \ldots, u_{N-1}` 
that takes the system to another continuous state :math:`s_{N}` in cell :math:`c_j`.
Hence, under the assumption that the specification is stutter invariant,
we can describe the continuous dynamics by an LTL formula of the form

.. math::
   (v = c_i) \implies next(\bigvee_{j \text{ s.t. } c_i \to c_j} v = c_j),

where :math:`v` is a new discrete variable that describes in which cell
the continuous state is.

Since the partition is proposition preserving, all the continuous states that belong
to the same cell satisfy exactly the same set of propositions on the continuous
state. By the abuse of notation, we write :math:`c_j \models X_i` if all the continuous
states in cell :math:`c_j` satisfy proposition :math:`X_i`.
Then, we can replace any proposition :math:`X_i` on the continuous state variables
by the formula :math:`\displaystyle{\bigvee_{j \text{ s.t. } c_j \models X_i} v = c_j}`.

Putting everything together, we now obtain a specification of the form in :eq:`spec`.
We can then use the GR(1) Game implementation in `JTLV <http://jtlv.ysaar.net/>`_ to 
automatically synthesize a planner that ensures the satisfaction of the specification,
taking into account all the possible behaviors of the environment.
This can be done using the following steps.

    1. Generate input to JTLV

        .. autofunction:: jtlvint.generateJTLVInput
	   :noindex:

    2. Synthesize the discrete planner

        .. autofunction:: jtlvint.computeStrategy
	   :noindex:

    3. Construct the automaton

        .. autoclass:: automaton.Automaton
	   :noindex:


Step 1 and 2 above can be combined using the following function:
        .. autofunction:: jtlvint.synthesize
	   :noindex:


Specification File and Parser
`````````````````````````````


Example 1: Robot Motion Planning with only Discrete Decisions
`````````````````````````````````````````````````````````````
This example is provided in examples/robot_discrete_simple.py.
It illustrates the use of the jtlvint module in synthesizing a planner
for a robot that only needs to make discrete decision.

.. image:: robot_discrete_simple.*
   :align: center

We consider the robot moving around the regions as shown in the above figure
while receiving externally triggered park signal.
The specification of the robot is

.. math::
   \varphi = \square \diamond(\neg park) \implies (\square \diamond(s \in C_5)
   \wedge \square(park \implies \diamond(s \in C_0))).

We cannot, however, deal with this specification directly since it is not in the form of 
GR[1].
An equivalent GR[1] specification of the above specification can be obtained
by introducing an auxiliary discretey system variable :math:`X0reach,` initialized to 
`True`. The transition relation of :math:`X0reach,` is given by
:math:`\square(\text{next}(X0reach) = ((s \in C_0 \vee X0reach) \wedge \neg park)).`

To automatically synthesize a planner for this robot, we first import the necessary modules.

.. literalinclude:: ../../examples/robot_discrete_simple.py
   :lines: 12-14

Specify the smv file, spc file and aut file.

.. literalinclude:: ../../examples/robot_discrete_simple.py
   :lines: 18-22

Specify the environment variables.

.. literalinclude:: ../../examples/robot_discrete_simple.py
   :lines: 25

Specify the discrete system variable.

.. literalinclude:: ../../examples/robot_discrete_simple.py
   :lines: 31

Specify the transition system representing the continuous dynamics.
First, we list the propositions on the continuous states.
Here, these propositions specify in which cell the robot is, 
i.e., Xi means that the robot is in cell Ci.
Then, we specify the regions.
Note that the first argument of Region(poly, prop) should be a list of 
polytopes. But since we are not dealing with the actual controller, we will 
just fill it with a string (think of it as a name of the region).
The second argument of Region(poly, prop) is a list that specifies which 
propositions in cont_props above is satisfied. As specified below, regioni 
satisfies proposition Xi.
Finally, we specify the adjacency between regions. 
disc_dynamics.adj[i][j] = 1 if starting from region j,
the robot can move to region i while only staying in the union of region i 
and region j.

.. literalinclude:: ../../examples/robot_discrete_simple.py
   :lines: 34, 38-39, 47-54, 59-64

Specification.

.. literalinclude:: ../../examples/robot_discrete_simple.py
   :lines: 67-69

Generate input to JTLV.

.. literalinclude:: ../../examples/robot_discrete_simple.py
   :lines: 72-73

Check realizability.

.. literalinclude:: ../../examples/robot_discrete_simple.py
   :lines: 76

Construct an automaton.

.. literalinclude:: ../../examples/robot_discrete_simple.py
   :lines: 79-80



Receding Horizon Temporal Logic Planning
----------------------------------------