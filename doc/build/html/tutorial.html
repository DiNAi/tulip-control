

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial and Examples &mdash; rhtlp v0.1.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="rhtlp v0.1.0 documentation" href="index.html" />
    <link rel="next" title="Receding horizon Temporal Logic Planning" href="rhtlp.html" />
    <link rel="prev" title="Introduction" href="intro.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rhtlp.html" title="Receding horizon Temporal Logic Planning"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="intro.html" title="Introduction"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">rhtlp v0.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tutorial-and-examples">
<h1>Tutorial and Examples<a class="headerlink" href="#tutorial-and-examples" title="Permalink to this headline">¶</a></h1>
<p>The rhtlp is developed for synthesis of embedded control systems,
allowing planning to be done in a receding horizon manner.
For more information regarding the theory behind this, please visit
our <a class="reference external" href="http://www.cds.caltech.edu/~utopcu/index.php/Receding_Horizon_Temporal_Logic_Planning_Toolbox_(RHTLP)">wiki</a>.</p>
<div class="section" id="synthesis-of-embedded-control-systems">
<h2>Synthesis of Embedded Control Systems<a class="headerlink" href="#synthesis-of-embedded-control-systems" title="Permalink to this headline">¶</a></h2>
<p>We consider a system that comprises the physical component, which we refer to as
the plant, and the (potentially dynamic and not a priori known) environment in
which the plant operates.
The system may contain both continuous (physical) and discrete (computational)
components.
In summary, the problem we are interested in consists of</p>
<blockquote>
<ul class="simple">
<li>discrete system state,</li>
<li>continuous system state,</li>
<li>(discrete) environment state, and</li>
<li>specification.</li>
</ul>
</blockquote>
<p>Here, <cite>discrete</cite> state refer to the state that can take only a finite number
of possible values while
<cite>continuous</cite> state refer to the state that can take an infinite number
of possible values, e.g., the position of the car.
The <cite>environment</cite> state is related to factors over which the system does not
have control such as the position of an obstacle and the outside temperature.
At any given time, the controller regulates the <cite>system</cite> (or <cite>controlled</cite>)
state such that the specification is satisfied, given the current value of the
environment variables and the previous system states.
We say that the specification is <cite>realizable</cite> if for any possible behavior
of the environment, such a controller exists, i.e., there exists a strategy
for the system to satisfy the specification.</p>
<p>Suppose the continuous state of the system evolves according to the
following discrete-time linear time-invariant state space model:
for <img class="math" src="_images/math/25c3702d367cd2c02c77ad61e439f3dac1799047.png" alt="t \in \{0,1,2,...\}"/></p>
<div class="math" id="equation-dynamics">
<p><span class="eqno">(1)</span><img src="_images/math/b1f10b70baff2f628915be231ca1541d0a25539b.png" alt="s[t+1]  &amp;=   As[t] + Bu[t] + Ed[t] \\
u[t]    &amp;\in U\\
d[t]    &amp;\in D\\
s[0]    &amp;\in S" /></p>
</div><p>where <img class="math" src="_images/math/317298ee9221eff0481453e9ac62815081b151cd.png" alt="S \subseteq \mathbb{R}^n"/> is the state space of the continuous
component of the system,
<img class="math" src="_images/math/fc6460508d02c81caf49307ac42384b43f4a89c7.png" alt="U \subseteq \mathbb{R}^m"/> is the set of admissible control inputs,
<img class="math" src="_images/math/b44f78abaffbddc7b2ac475bf6a95affb1a96dcc.png" alt="D \subseteq \mathbb{R}^p"/> is the set of exogenous disturbances and
<img class="math" src="_images/math/1c7a315650e2379262eb5bee0f997d7ab5a6e95a.png" alt="s[t], u[t], d[t]"/> are the continuous state, the control signal and
the exogenous disturbance, respectively, at time <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/>.</p>
<p>We consider the case where the sets <img class="math" src="_images/math/d1e2e2a0f2601b2ac74356133ba564a081a61d78.png" alt="S, U, D"/> are bounded polytopes.</p>
<p>Let <img class="math" src="_images/math/c3e77f8dac39bd44cff4ca15469c871bab27c02e.png" alt="\Pi"/> be a finite set of atomic propositions of system variables.
Each of the atomic propositions in <img class="math" src="_images/math/c3e77f8dac39bd44cff4ca15469c871bab27c02e.png" alt="\Pi"/> essentially captures the
states of interest.
We consider the specification of the form</p>
<div class="math" id="equation-spec">
<p><span class="eqno">(2)</span><img src="_images/math/1a70bc0795ec80a9f18a054288dfb11fda3c38a1.png" alt="\varphi = \big(\varphi_{init} \wedge \varphi_e) \implies \varphi_s." /></p>
</div><p>Here, the assumption <img class="math" src="_images/math/b61609b6700e21c53c4b382101cf000539ad2d22.png" alt="\varphi_{init}"/> on the initial condition of the system
is a propositional formula built from <img class="math" src="_images/math/1a5deef5cb28b0e3cbff3c3c17037341fdeb55cb.png" alt="\Pi."/>
The assumption <img class="math" src="_images/math/a083a57c95393bde438cc281148de64143326583.png" alt="\varphi_e"/> on the environment and the desired behavior
<img class="math" src="_images/math/8e4478eaa04cebf3657c2e00c0bef97ce62440d5.png" alt="\varphi_s"/> are LTL formulas built from <img class="math" src="_images/math/1a5deef5cb28b0e3cbff3c3c17037341fdeb55cb.png" alt="\Pi."/>
See our <a class="reference external" href="http://www.cds.caltech.edu/~utopcu/index.php/Receding_Horizon_Temporal_Logic_Planning_Toolbox_(RHTLP)">wiki</a> for more details on the form of <img class="math" src="_images/math/a1bd9c588c681f5241c603c770ef650ef4ecbe6e.png" alt="\varphi_e, \varphi_s"/>.</p>
<img alt="_images/ecssyn.png" src="_images/ecssyn.png" />
<p>As illustrated in the figure above, our approach to this embedded control
system synthesis consists of the following main steps:</p>
<blockquote>
<ol class="arabic simple">
<li><a class="reference internal" href="#ssec-prop-part"><em>Generate a proposition preserving partition of the continuous state space.</em></a></li>
<li><a class="reference internal" href="#ssec-disc"><em>Discretize the continuous state space based on the evolution of the continuous state.</em></a></li>
<li><a class="reference internal" href="#ssec-syn"><em>Digital design synthesis.</em></a></li>
</ol>
</blockquote>
<div class="section" id="proposition-preserving-partition-of-continuous-state-space">
<span id="ssec-prop-part"></span><h3>Proposition Preserving Partition of Continuous State Space<a class="headerlink" href="#proposition-preserving-partition-of-continuous-state-space" title="Permalink to this headline">¶</a></h3>
<p>Given the continuous state space <img class="math" src="_images/math/ad28c83c99a8fd0dd2e2e594c9d02ee532765a0a.png" alt="S"/> of the system and the set <img class="math" src="_images/math/4cacf873292b07ee905dcb1b5ddb682d0f11fafa.png" alt="\Pi_c"/> of
propositions on the continuous state of the system, we partition <img class="math" src="_images/math/ad28c83c99a8fd0dd2e2e594c9d02ee532765a0a.png" alt="S"/> into a finite
number of cells such that all the continuous states in each cell satisfy exactly the
same set of propositions in <img class="math" src="_images/math/4cacf873292b07ee905dcb1b5ddb682d0f11fafa.png" alt="\Pi_c"/>.</p>
<p>This can be done using the following function call:</p>
<blockquote>
<dl class="function">
<dt>
<tt class="descclassname">prop2part.</tt><tt class="descname">prop2part2</tt><big>(</big><em>state_space</em>, <em>cont_props_dict</em><big>)</big><a class="reference internal" href="_modules/prop2part.html#prop2part2"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Main function that takes a domain (state_space) and a list of propositions (cont_props), and
returns a proposition preserving partition of the state space</p>
</dd></dl>

</blockquote>
<p>The above function returns a proposition preserving partition as a PropPreservingPartition object.</p>
<blockquote>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">prop2part.</tt><tt class="descname">PropPreservingPartition</tt><big>(</big><em>domain=None</em>, <em>num_prop=0</em>, <em>list_region=</em><span class="optional">[</span><span class="optional">]</span>, <em>num_regions=0</em>, <em>adj=0</em>, <em>trans=0</em>, <em>list_prop_symbol=None</em><big>)</big><a class="reference internal" href="_modules/prop2part.html#PropPreservingPartition"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Partition class with following fields</p>
<ul class="simple">
<li>domain: the domain we want to partition, type: polytope</li>
<li>num_prop: number of propositions</li>
<li>list_region: proposition preserving regions, type: list of Region</li>
<li>num_regions: length of the above list</li>
<li>adj: a matrix showing which regions are adjacent</li>
<li>trans: a matrix showing which region is reachable from which region</li>
<li>list_prop_symbol: list of symbols of propositions</li>
</ul>
</dd></dl>

</blockquote>
</div>
<div class="section" id="continuous-state-space-discretization">
<span id="ssec-disc"></span><h3>Continuous State Space Discretization<a class="headerlink" href="#continuous-state-space-discretization" title="Permalink to this headline">¶</a></h3>
<p>Given a proposition preserving partition of the continuous state space and
the evolution of the continuous state as in <a href="#equation-dynamics">(1)</a>,
we refine the partition based on the reachability relation between cells
and obtain a finite state abstraction of the evolution of the continuous state,
represented by a finite transition system.</p>
<p>CtsSysDyn class is used to define continuous dynamics.</p>
<blockquote>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">discretizeM.</tt><tt class="descname">CtsSysDyn</tt><big>(</big><em>A=</em><span class="optional">[</span><span class="optional">]</span>, <em>B=</em><span class="optional">[</span><span class="optional">]</span>, <em>E=</em><span class="optional">[</span><span class="optional">]</span>, <em>Uset=</em><span class="optional">[</span><span class="optional">]</span>, <em>Wset=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/discretizeM.html#CtsSysDyn"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>CtsSysDyn class for specifying the continuous dynamics:</p>
<blockquote>
s[t+1] = A*s[t] + B*u[t] + E*w[t]
u[t] in Uset - polytope object
d[t] in Wset - polytope object</blockquote>
<p>A CtsSysDyn object contains the fields A, B, E, Uset and Wset as defined above.</p>
<p><strong>Constructor</strong>:</p>
<p><strong>CtsSysDyn</strong> ([ <cite>A</cite> = [][, <cite>B</cite> = [][, <cite>E</cite> = [][, <cite>Uset</cite> = [][, <cite>Wset</cite> = []]]]]])</p>
</dd></dl>

</blockquote>
<p>Once we have the proposition preserving partition and the continuous dynamics,
continuous state space discretization can be done using the following function call:</p>
<blockquote>
<dl class="function">
<dt>
<tt class="descclassname">discretizeM.</tt><tt class="descname">discretizeM</tt><big>(</big><em>part</em>, <em>ssys</em>, <em>N=10</em>, <em>auto=True</em>, <em>minCellVolume=0.10000000000000001</em>, <em>maxNumIterations=5</em>, <em>useClosedLoopAlg=True</em>, <em>useAllHorizonLength=True</em>, <em>useLargeSset=False</em>, <em>timeout=-1</em>, <em>maxNumPoly=5</em>, <em>verbose=0</em><big>)</big><a class="reference internal" href="_modules/discretizeM.html#discretizeM"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Discretize the continuous state space using MATLAB implementation.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>part</cite>: a PropPreservingPartition object</li>
<li><cite>ssys</cite>: a CtsSysDyn object</li>
<li><cite>N</cite>: horizon length</li>
<li><cite>auto</cite>: a boolean that indicates whether to automatically run the MATLAB  
implementation of discretize.</li>
<li><cite>minCellVolume</cite>: the minimum volume of cells in the resulting partition</li>
<li><cite>maxNumIterations</cite>: the maximum number of iterations</li>
<li><cite>useClosedLoopAlg</cite>: a boolean that indicates whether to use the closed loop algorithm.
For the difference between the closed loop and the open loop algorithm, 
see Borrelli, F. Constrained Optimal Control of Linear and Hybrid Systems, 
volume 290 of Lecture Notes in Control and Information Sciences. Springer. 2003.</li>
<li><cite>useAllHorizonLength</cite>: a boolean that indicates whether all the horizon length up
to probStruct.N can be used. This option is relevant only when the closed 
loop algorithm is used.</li>
<li><cite>useLargeSset</cite>: a boolean that indicates whether when solving the reachability
problem between subcells of the original partition, the cell of the
original partition should be used for the safe set.</li>
<li><cite>timeout</cite>: timeout (in seconds) for polytope union operation. 
If negative, the timeout won&#8217;t be used. Note that using timeout requires MATLAB
parallel computing toolbox.</li>
<li><cite>maxNumPoly</cite>: the maximum number of polytopes in a region used in computing reachability.</li>
<li><cite>verbose</cite>: level of verbosity</li>
</ul>
</dd></dl>

</blockquote>
</div>
<div class="section" id="digital-design-synthesis">
<span id="ssec-syn"></span><h3>Digital design synthesis<a class="headerlink" href="#digital-design-synthesis" title="Permalink to this headline">¶</a></h3>
<p>The continuous state space discretization generates a finite state abstraction
of the continuous state, represented by a finite transition system.
Each state in this finite transition system corresponds to a cell in the continuous
domain.
A transition <img class="math" src="_images/math/b973745a4e4aa10751e09d75093a0cdb499ad6e9.png" alt="c_i \to c_j"/> in this finite state system indicates that
from any continuous state <img class="math" src="_images/math/058418cc5858eeab7f1ceb92f70b1c00fe7fe5d6.png" alt="s_0"/> that belongs to cell <img class="math" src="_images/math/1e95be43c04d6869c67861aae1e3e69123fedd8c.png" alt="c_i"/>,
there exists a sequence of control inputs <img class="math" src="_images/math/ada5ca63358e53658cbc8abb13da29105c0ff2a2.png" alt="u_0, u_1, \ldots, u_{N-1}"/>
that takes the system to another continuous state <img class="math" src="_images/math/8f7bb52379015c473901c36dad1c1e3b7ade04a0.png" alt="s_{N}"/> in cell <img class="math" src="_images/math/88d143238ae2718841dfd3ec099cbea395db77a4.png" alt="c_j"/>.
Hence, under the assumption that the specification is stutter invariant,
we can describe the continuous dynamics by an LTL formula of the form</p>
<div class="math">
<p><img src="_images/math/d4fcc021d52b36d535d15869a9fcbe7ad4d78af6.png" alt="(v = c_i) \implies next(\bigvee_{j \text{ s.t. } c_i \to c_j} v = c_j)," /></p>
</div><p>where <img class="math" src="_images/math/a9f23bf124b6b2b2a993eb313c72e678664ac74a.png" alt="v"/> is a new discrete variable that describes in which cell
the continuous state is.</p>
<p>Since the partition is proposition preserving, all the continuous states that belong
to the same cell satisfy exactly the same set of propositions on the continuous
state. By the abuse of notation, we write <img class="math" src="_images/math/e7fd60e5129d117276dcebc9600e5632ea06251a.png" alt="c_j \models X_i"/> if all the continuous
states in cell <img class="math" src="_images/math/88d143238ae2718841dfd3ec099cbea395db77a4.png" alt="c_j"/> satisfy proposition <img class="math" src="_images/math/5f8e5cbb6204882df1cf17cfe4b308d485af8056.png" alt="X_i"/>.
Then, we can replace any proposition <img class="math" src="_images/math/5f8e5cbb6204882df1cf17cfe4b308d485af8056.png" alt="X_i"/> on the continuous state variables
by the formula <img class="math" src="_images/math/d6535b57faa547bb2d28ffc2008b060acb78e4a9.png" alt="\displaystyle{\bigvee_{j \text{ s.t. } c_j \models X_i} v = c_j}"/>.</p>
<p>Putting everything together, we now obtain a specification of the form in <a href="#equation-spec">(2)</a>.
We can then use the GR(1) Game implementation in <a class="reference external" href="http://jtlv.ysaar.net/">JTLV</a> to
automatically synthesize a planner that ensures the satisfaction of the specification,
taking into account all the possible behaviors of the environment.
This can be done using the following steps.</p>
<blockquote>
<ol class="arabic">
<li><p class="first">Generate input to JTLV</p>
<blockquote>
<dl class="function">
<dt>
<tt class="descclassname">jtlvint.</tt><tt class="descname">generateJTLVInput</tt><big>(</big><em>env_vars={}</em>, <em>sys_disc_vars={}</em>, <em>spec=</em><span class="optional">[</span><span class="optional">]</span>, <em>disc_props={}</em>, <em>disc_dynamics=&lt;prop2part.PropPreservingPartition instance at 0x103ad4710&gt;</em>, <em>smv_file='tmp.smv'</em>, <em>spc_file='tmp.spc'</em>, <em>file_exist_option='a'</em>, <em>verbose=0</em><big>)</big><a class="reference internal" href="_modules/jtlvint.html#generateJTLVInput"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Generate JTLV input files: smv_file and spc_file.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>env_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the names 
of environment variables and whose values are their possible values, e.g., 
boolean or {0, 2, ..., 5} or [0, 2, 3, 4, 5].</li>
<li><cite>sys_disc_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the 
names of discrete system variables and whose values are their possible values.</li>
<li><cite>spec</cite>: a list of two strings that represents system specification of the form
assumption -&gt; guarantee; the first string is the assumption and the second 
string is the guarantee.</li>
<li><cite>disc_props</cite>: a dictionary {str : str} whose keys are the symbols for 
propositions on discrete variables and whose values are the actual propositions
on discrete variables.</li>
<li><cite>disc_dynamics</cite>: a PropPreservingPartition object that represents the 
transition system obtained from the discretization procedure.</li>
<li><cite>smv_file</cite>: a string that specifies the name of the resulting smv file.</li>
<li><cite>spc_file</cite>: a string that specifies the name of the resulting spc file.</li>
<li><cite>file_exist_option</cite>: a string that indicate what to do when the specified smv_file 
or spc_file exists. Possible values are: &#8216;a&#8217; (ask whether to replace or
create a new file), &#8216;r&#8217; (replace the existing file), &#8216;n&#8217; (create a new file).</li>
<li><cite>verbose</cite>: an integer that specifies the level of verbosity. If verbose is set to 0,
this function will not print anything on the screen.</li>
</ul>
</dd></dl>

</blockquote>
</li>
<li><p class="first">Synthesize the discrete planner</p>
<blockquote>
<dl class="function">
<dt>
<tt class="descclassname">jtlvint.</tt><tt class="descname">computeStrategy</tt><big>(</big><em>smv_file</em>, <em>spc_file</em>, <em>aut_file=''</em>, <em>heap_size='-Xmx128m'</em>, <em>priority_kind=3</em>, <em>init_option=1</em>, <em>file_exist_option='a'</em>, <em>verbose=0</em><big>)</big><a class="reference internal" href="_modules/jtlvint.html#computeStrategy"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Compute an automaton satisfying the spec in smv_file and spc_file and store in 
aut_file. Return the realizability of the spec.</p>
<p>Input:</p>
<ul>
<li><p class="first"><cite>smv_file</cite>: a string that specifies the name of the smv file.</p>
</li>
<li><p class="first"><cite>spc_file</cite>: a string that specifies the name of the spc file.</p>
</li>
<li><p class="first"><cite>aut_file</cite>: a string that specifies the name of the file containing the resulting 
automaton.</p>
</li>
<li><p class="first"><cite>heap_size</cite>: a string that specifies java heap size.</p>
</li>
<li><p class="first"><cite>priority_kind</cite>: a string of length 3 or an integer that specifies the type of 
priority used in extracting the automaton. Possible values of <cite>priority_kind</cite> are:</p>
<blockquote>
<ul class="simple">
<li>3 - &#8216;ZYX&#8217;</li>
<li>7 - &#8216;ZXY&#8217;</li>
<li>11 - &#8216;YZX&#8217;</li>
<li>15 - &#8216;YXZ&#8217;</li>
<li>19 - &#8216;XZY&#8217;</li>
<li>23 - &#8216;XYZ&#8217;</li>
</ul>
</blockquote>
<p>Here X means that the controller tries to disqualify one of the environment 
assumptions, 
Y means that the controller tries to advance with a finite path to somewhere, and
Z means that the controller tries to satisfy one of his guarantees.</p>
</li>
<li><p class="first"><cite>init_option</cite>: an integer in that specifies how to handle the initial state of 
the system. Possible values of <cite>init_option</cite> are</p>
<blockquote>
<ul class="simple">
<li>0 - The system has to be able to handle all the possible initial system
states specified on the guarantee side of the specification.</li>
<li>1 (default) - The system can choose its initial state, in response to the initial
environment state. For each initial environment state, the resulting
automaton contains exactly one initial system state, starting from which
the system can satisfy the specification.</li>
<li>2 - The system can choose its initial state, in response to the initial
environment state. For each initial environment state, the resulting
automaton contain all the possible initial system states, starting from which
the system can satisfy the specification.</li>
</ul>
</blockquote>
</li>
<li><p class="first"><cite>file_exist_option</cite>: a string that indicate what to do when the specified aut_file 
exists. Possible values are: &#8216;a&#8217; (ask whether to replace or create a new file), 
&#8216;r&#8217; (replace the existing file), &#8216;n&#8217; (create a new file).</p>
</li>
<li><p class="first"><cite>verbose</cite>: an integer that specifies the level of verbosity.</p>
</li>
</ul>
</dd></dl>

</blockquote>
</li>
<li><p class="first">Construct the automaton</p>
<blockquote>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">automaton.</tt><tt class="descname">Automaton</tt><big>(</big><em>states_or_file=</em><span class="optional">[</span><span class="optional">]</span>, <em>varnames=</em><span class="optional">[</span><span class="optional">]</span>, <em>verbose=0</em><big>)</big><a class="reference internal" href="_modules/automaton.html#Automaton"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Automaton class for representing a finite state automaton.
An Automaton object contains the following field:</p>
<ul class="simple">
<li><cite>states</cite>: a list of AutomatonState objects.</li>
</ul>
<p>Automaton([states_or_file, varname, verbose]) constructs an Automaton object based
on the following input:</p>
<ul class="simple">
<li><cite>states_or_file</cite>: a string containing the name of the aut file to be loaded or
a list of AutomatonState objects to be assigned to the <cite>states</cite> of this 
Automaton object.</li>
<li><cite>varname</cite>: a list of all the variable names. If it is not empty and 
states_or_file is a string representing the name of the aut file to be loaded, 
then this function will also check whether the variables in aut_file are in 
varnames.</li>
</ul>
</dd></dl>

</blockquote>
</li>
</ol>
</blockquote>
<dl class="docutils">
<dt>Step 1 and 2 above can be combined using the following function:</dt>
<dd><dl class="first last function">
<dt>
<tt class="descclassname">jtlvint.</tt><tt class="descname">synthesize</tt><big>(</big><em>env_vars={}</em>, <em>sys_disc_vars={}</em>, <em>spec=''</em>, <em>disc_props={}</em>, <em>disc_dynamics=&lt;prop2part.PropPreservingPartition instance at 0x103ad4440&gt;</em>, <em>smv_file='tmp.smv'</em>, <em>spc_file='tmp.spc'</em>, <em>aut_file=''</em>, <em>heap_size='-Xmx128m'</em>, <em>priority_kind=3</em>, <em>init_option=1</em>, <em>file_exist_option='a'</em>, <em>verbose=0</em><big>)</big><a class="reference internal" href="_modules/jtlvint.html#synthesize"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Compute an automaton satisfying <cite>spec</cite>. Return the realizability of <cite>spec</cite>.
If <cite>spec</cite> is realizable, the resulting automaton will be stored in the
<cite>aut_file</cite>. Otherwise, the counter examples will be stored.
This function essentially combines <tt class="docutils literal"><span class="pre">generateJTLVInput</span></tt> and <tt class="docutils literal"><span class="pre">computeStrategy</span></tt></p>
<p>Input:</p>
<ul class="simple">
<li><cite>env_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the names 
of environment variables and whose values are their possible values, e.g., 
boolean or {0, 2, ..., 5} or [0, 2, 3, 4, 5].</li>
<li><cite>sys_disc_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the 
names of discrete system variables and whose values are their possible values.</li>
<li><cite>spec</cite>: a list of two strings that represents system specification of the form
assumption -&gt; guarantee; the first string is the assumption and the second 
string is the guarantee.</li>
<li><cite>disc_props</cite>: a dictionary {str : str} whose keys are the symbols for 
propositions on discrete variables and whose values are the actual propositions
on discrete variables.</li>
<li><cite>disc_dynamics</cite>: a PropPreservingPartition object that represents the 
transition system obtained from the discretization procedure.</li>
<li><cite>smv_file</cite>: a string that specifies the name of the resulting smv file.</li>
<li><cite>spc_file</cite>: a string that specifies the name of the resulting spc file.</li>
<li><cite>aut_file</cite>: a string that specifies the name of the file containing the resulting 
automaton.</li>
<li><cite>heap_size</cite>: a string that specifies java heap size.</li>
<li><cite>priority_kind</cite>: a string of length 3 or an integer that specifies the type of 
priority used in extracting the automaton. See the documentation of the 
<tt class="docutils literal"><span class="pre">computeStrategy</span></tt> function for the possible values of <cite>priority_kind</cite>.</li>
<li><cite>init_option</cite>: an integer in that specifies how to handle the initial state of 
the system. See the documentation of the <tt class="docutils literal"><span class="pre">computeStrategy</span></tt> function for the 
possible values of <cite>init_option</cite>.</li>
<li><cite>file_exist_option</cite>: a string that indicate what to do when the specified smv_file 
or spc_file exists. Possible values are: &#8216;a&#8217; (ask whether to replace or
create a new file), &#8216;r&#8217; (replace the existing file), &#8216;n&#8217; (create a new file).</li>
<li><cite>verbose</cite>: an integer that specifies the level of verbosity. If verbose is set to 0,
this function will not print anything on the screen.</li>
</ul>
</dd></dl>

</dd>
</dl>
</div>
<div class="section" id="example-1-robot-motion-planning-with-only-discrete-decisions">
<span id="ssec-ex1"></span><h3>Example 1: Robot Motion Planning with only Discrete Decisions<a class="headerlink" href="#example-1-robot-motion-planning-with-only-discrete-decisions" title="Permalink to this headline">¶</a></h3>
<p>This example is provided in examples/robot_discrete_simple.py.
It illustrates the use of the jtlvint module in synthesizing a planner
for a robot that only needs to make discrete decision.</p>
<img alt="_images/robot_discrete_simple.png" class="align-center" src="_images/robot_discrete_simple.png" />
<p>We consider the robot moving around the regions as shown in the above figure
while receiving externally triggered park signal.
The specification of the robot is</p>
<div class="math">
<p><img src="_images/math/85215bbd9909bf6eab7c19862eea6fb2ddf0b7db.png" alt="\varphi = \square \diamond(\neg park) \implies (\square \diamond(s \in C_5)
\wedge \square(park \implies \diamond(s \in C_0)))." /></p>
</div><p>We cannot, however, deal with this specification directly since it is not in the form of
GR[1].
An equivalent GR[1] specification of the above specification can be obtained
by introducing an auxiliary discretey system variable <img class="math" src="_images/math/690964dcdace4b821563dcd325aa63d28671294b.png" alt="X0reach,"/> initialized to
<cite>True</cite>. The transition relation of <img class="math" src="_images/math/690964dcdace4b821563dcd325aa63d28671294b.png" alt="X0reach,"/> is given by
<img class="math" src="_images/math/f8ee251715395c66d357f5331eeb4c7b9a51571e.png" alt="\square(\text{next}(X0reach) = ((s \in C_0 \vee X0reach) \wedge \neg park))."/></p>
<p>To automatically synthesize a planner for this robot, we first import the necessary modules.</p>
<div class="highlight-rst"><div class="highlight"><pre>from prop2part import Region, PropPreservingPartition
from jtlvint import *
from automaton import *
from grsim import grsim
</pre></div>
</div>
<p>Specify the smv file, spc file and aut file.</p>
<div class="highlight-rst"><div class="highlight"><pre>testfile = &#39;robot_discrete_simple&#39;
path = os.path.abspath(os.path.dirname(sys.argv[0]))
smvfile = os.path.join(path, &#39;specs&#39;, testfile+&#39;.smv&#39;)
spcfile = os.path.join(path, &#39;specs&#39;, testfile+&#39;.spc&#39;)
autfile = os.path.join(path, &#39;specs&#39;, testfile+&#39;.aut&#39;)
</pre></div>
</div>
<p>Specify the environment variables.</p>
<div class="highlight-rst"><div class="highlight"><pre>env_vars = {&#39;park&#39; : &#39;boolean&#39;}
</pre></div>
</div>
<p>Specify the discrete system variable.</p>
<div class="highlight-rst"><div class="highlight"><pre>sys_disc_vars = {&#39;X0reach&#39; : &#39;boolean&#39;}
</pre></div>
</div>
<p>Specify the transition system representing the continuous dynamics.
First, we list the propositions on the continuous states.
Here, these propositions specify in which cell the robot is,
i.e., Xi means that the robot is in cell Ci.
Then, we specify the regions.
Note that the first argument of Region(poly, prop) should be a list of
polytopes. But since we are not dealing with the actual controller, we will
just fill it with a string (think of it as a name of the region).
The second argument of Region(poly, prop) is a list that specifies which
propositions in cont_props above is satisfied. As specified below, regioni
satisfies proposition Xi.
Finally, we specify the adjacency between regions.
disc_dynamics.adj[i][j] = 1 if starting from region j,
the robot can move to region i while only staying in the union of region i
and region j.</p>
<div class="highlight-rst"><div class="highlight"><pre>disc_dynamics = PropPreservingPartition(list_region=[], list_prop_symbol=[])
disc_dynamics.list_prop_symbol = [&#39;X0&#39;, &#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;, &#39;X5&#39;] 
disc_dynamics.num_prop = len(disc_dynamics.list_prop_symbol)
region0 = Region(&#39;C0&#39;, [1, 0, 0, 0, 0, 0])
region1 = Region(&#39;C1&#39;, [0, 1, 0, 0, 0, 0])
region2 = Region(&#39;C2&#39;, [0, 0, 1, 0, 0, 0])
region3 = Region(&#39;C3&#39;, [0, 0, 0, 1, 0, 0])
region4 = Region(&#39;C4&#39;, [0, 0, 0, 0, 1, 0])
region5 = Region(&#39;C5&#39;, [0, 0, 0, 0, 0, 1])
disc_dynamics.list_region = [region0, region1, region2, region3, region4, region5]
disc_dynamics.num_regions = len(disc_dynamics.list_region)
disc_dynamics.trans =   [[1, 1, 0, 1, 0, 0], \
                         [1, 1, 1, 0, 1, 0], \
                         [0, 1, 1, 0, 0, 1], \
                         [1, 0, 0, 1, 1, 0], \
                         [0, 1, 0, 1, 1, 1], \
                         [0, 0, 1, 0, 1, 1]]
</pre></div>
</div>
<p>Specification.</p>
<div class="highlight-rst"><div class="highlight"><pre>assumption = &#39;X0reach &amp; []&lt;&gt;(!park)&#39;
guarantee = &#39;[]&lt;&gt;X5 &amp; []&lt;&gt;(X0reach)&#39;
guarantee += &#39; &amp; [](next(X0reach) = ((X0 | X0reach) &amp; !park))&#39;
</pre></div>
</div>
<p>Generate input to JTLV.</p>
<div class="highlight-rst"><div class="highlight"><pre>prob = generateJTLVInput(env_vars, sys_disc_vars, [assumption, guarantee], \
                                   {}, disc_dynamics, smvfile, spcfile, verbose=2)
</pre></div>
</div>
<p>Check realizability.</p>
<div class="highlight-rst"><div class="highlight"><pre>realizability = checkRealizability(smv_file=smvfile, spc_file=spcfile, \
                                       aut_file=autfile, verbose=3)
</pre></div>
</div>
<p>Construct an automaton.</p>
<div class="highlight-rst"><div class="highlight"><pre>computeStrategy(smv_file=smvfile, spc_file=spcfile, aut_file=autfile, \
                                    priority_kind=3, verbose=3)
</pre></div>
</div>
<p>Run simulation.</p>
<div class="highlight-rst"><div class="highlight"><pre>num_it = 30
init_state = {}
init_state[&#39;X0reach&#39;] = True
env_states = []
for i in xrange(0,num_it):
    if (i%3 == 0):
        env_states.append({&#39;park&#39;:True})
    else:
        env_states.append({&#39;park&#39;:False})

states = grsim(aut, init_state, env_states, num_it)
</pre></div>
</div>
</div>
<div class="section" id="example-2-robot-motion-planning">
<span id="ssec-ex2"></span><h3>Example 2: Robot Motion Planning<a class="headerlink" href="#example-2-robot-motion-planning" title="Permalink to this headline">¶</a></h3>
<p>This example is provided in examples/robot_simple.py.
It is an extension of the previous example by including continuous dynamics.</p>
<p>First, we import the necessary modules,
specify the smv file, spc file and aut file,
and specify the environment and the discrete system variables
as in the previous example.</p>
<div class="highlight-rst"><div class="highlight"><pre>from prop2part import Polytope, Region, PropPreservingPartition, prop2part2
from discretizeM import CtsSysDyn, discretizeM
from jtlvint import *
from automaton import *
from numpy import array
from grsim import grsim

testfile = &#39;robot_simple&#39;
path = os.path.abspath(os.path.dirname(sys.argv[0]))
smvfile = os.path.join(path, &#39;specs&#39;, testfile+&#39;.smv&#39;)
spcfile = os.path.join(path, &#39;specs&#39;, testfile+&#39;.spc&#39;)
autfile = os.path.join(path, &#39;specs&#39;, testfile+&#39;.aut&#39;)

env_vars = {&#39;park&#39; : &#39;boolean&#39;}
sys_disc_vars = {&#39;X0reach&#39; : &#39;boolean&#39;}
</pre></div>
</div>
<p>Next, we specify the continuous dynamics.
This includes specifying the continuous state space, propositions on continuous variables,
and the dynamics.
The robot dynamics in this case is <img class="math" src="_images/math/4ea869623c40b295e25c245bb202ed2077567ecc.png" alt="\dot{x} = u_x, \dot{y} = u_y."/></p>
<div class="highlight-rst"><div class="highlight"><pre>cont_state_space = Polytope(array([[1., 0.],[-1., 0.], [0., 1.], [0., -1.]]), \
                                   array([[3.],[0.],[2.],[0.]]))

cont_props = {}
for i in xrange(0, 3):
    for j in xrange(0,2):
        prop_sym = &#39;X&#39; + str(3*j + i)
        cont_props[prop_sym] = Polytope(array([[1., 0.],[-1., 0.], [0., 1.], [0., -1.]]), \
                                   array([[float(i+1)],[float(-i)],[float(j+1)],[float(-j)]]))

A = array([[1.1052, 0.],[ 0., 1.1052]])
B = array([[1.1052, 0.],[ 0., 1.1052]])
U = Polytope(array([[1., 0.],[-1., 0.], [0., 1.], [0., -1.]]), array([[1.],[1.],[1.],[1.]]))
sys_dyn = CtsSysDyn(A,B,[],U,[])
</pre></div>
</div>
<p>Now, we can construct the proposition preserving partition of the continuous state space
and discretize the continuous state space based on the dynamics.</p>
<div class="highlight-rst"><div class="highlight"><pre>cont_partition = prop2part2(cont_state_space, cont_props)
disc_dynamics = discretizeM(cont_partition, sys_dyn, verbose=2)
</pre></div>
</div>
<p>The rest is the same as in the previous example.
We specify system specification,
generate input to JTLV,
check realizability,
construct an automaton,
and run simulation.</p>
<div class="highlight-rst"><div class="highlight"><pre>prob = generateJTLVInput(env_vars, sys_disc_vars, [assumption, guarantee], \
                                   {}, disc_dynamics, smvfile, spcfile, verbose=2)

realizability = checkRealizability(smv_file=smvfile, spc_file=spcfile, \
                                       aut_file=autfile, verbose=3)

computeStrategy(smv_file=smvfile, spc_file=spcfile, aut_file=autfile, \
                                    priority_kind=3, verbose=3)
aut = Automaton(autfile, [], 3)

num_it = 30
init_state = {}
init_state[&#39;X0reach&#39;] = True
env_states = []
for i in xrange(0,num_it):
    if (i%3 == 0):
        env_states.append({&#39;park&#39;:True})
    else:
        env_states.append({&#39;park&#39;:False})

states = grsim(aut, init_state, env_states, num_it)
</pre></div>
</div>
</div>
<div class="section" id="defining-a-synthesis-problem">
<h3>Defining a Synthesis Problem<a class="headerlink" href="#defining-a-synthesis-problem" title="Permalink to this headline">¶</a></h3>
<p>SynthesisProb class provides a self-contained structure for defining
an embedded control software synthesis problem.
It contains several useful functions that allow the problem to be solved in one shot,
combining the 3 steps as previously described.</p>
<blockquote>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">rhtlp.</tt><tt class="descname">SynthesisProb</tt><big>(</big><em>**args</em><big>)</big><a class="reference internal" href="_modules/rhtlp.html#SynthesisProb"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>SynthesisProb class for specifying a planner synthesis problem.
A SynthesisProb object contains the following fields:</p>
<ul class="simple">
<li><cite>env_vars</cite>: a dictionary {str : str} whose keys are the names 
of environment variables and whose values are their possible values, e.g., 
boolean or {0, 2, 3, 4, 5}.</li>
<li><cite>sys_vars</cite>: a dictionary {str : str} whose keys are the 
names of system variables and whose values are their possible values.</li>
<li><cite>spec</cite>: a GRSpec object that specifies the specification of this synthesis problem.</li>
<li><cite>disc_cont_var</cite>: the name of the continuous variable after the discretization.</li>
<li><cite>disc_dynamics</cite>: a list of Region objects corresponding to the partition of the
continuous state space.</li>
</ul>
<p><strong>Constructor</strong>:</p>
<p><strong>SynthesisProb</strong> ([ <cite>file</cite> = &#8216;&#8217;[, <cite>verbose</cite> = 0]]): 
construct this SynthesisProb object from file</p>
<ul class="simple">
<li><cite>file</cite>: the name of the rhtlp file to be parsed. If <cite>file</cite> is given,
the rest of the inputs to this function will be ignored.</li>
</ul>
<p><strong>SynthesisProb</strong> ([ <cite>env_vars</cite> = {}[, <cite>sys_disc_vars</cite> = {}[, <cite>disc_props</cite> = {}[, 
<cite>disc_dynamics</cite> = None[, <cite>spec</cite> = GRSpec()[, <cite>verbose</cite> = 0]]]]]])</p>
<p><strong>SynthesisProb</strong> ([ <cite>env_vars</cite> = {}[, <cite>sys_disc_vars</cite> = {}[, <cite>disc_props</cite> = {}[, 
<cite>cont_state_space</cite> = None[, <cite>cont_props</cite> = {}[, <cite>sys_dyn</cite> = None[, 
<cite>spec</cite> = GRSpec()[, <cite>verbose</cite> = 0]]]]]]]])</p>
<ul class="simple">
<li><cite>env_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the names 
of environment variables and whose values are their possible values, e.g., 
boolean or {0, 2, ..., 5} or [0, 2, 3, 4, 5].</li>
<li><cite>sys_disc_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the 
names of discrete system variables and whose values are their possible values.</li>
<li><cite>disc_props</cite>: a dictionary {str : str} whose keys are the symbols for 
propositions on discrete variables and whose values are the actual propositions
on discrete variables.</li>
<li><cite>disc_dynamics</cite>: a PropPreservingPartition object that represents the 
transition system obtained from the discretization procedure.
if <cite>disc_dynamics</cite> is given, <cite>cont_state_space</cite>, <cite>cont_props</cite> and <cite>sys_dyn</cite>
will be ignored.</li>
<li><cite>cont_state_space</cite>: a Polytope object that represent the state space of the
continuous variables</li>
<li><cite>cont_props</cite>: a dictionary {str : Polytope} whose keys are the symbols for 
propositions on continuous variables and whose values are polytopes that represent
the region in the state space in which the corresponding proposition hold.</li>
<li><cite>sys_dyn</cite>: a CtsSysDyn object that specifies the dynamics of the continuous variables</li>
<li><cite>spec</cite>: a GRSpec object that specifies the specification of this synthesis problem</li>
<li><cite>verbose</cite>: an integer that specifies the level of verbosity.</li>
</ul>
</dd></dl>

</blockquote>
</div>
<div class="section" id="example-3-robot-motion-planning-using-synthesisprob">
<h3>Example 3: Robot Motion Planning using SynthesisProb<a class="headerlink" href="#example-3-robot-motion-planning-using-synthesisprob" title="Permalink to this headline">¶</a></h3>
<p>This example is provided in examples/robot_simple2.py.
It is exactly the same problem as <a class="reference internal" href="#ssec-ex2"><em>Example 2</em></a>
but solved using SynthesisProb, instead of the jtlvint module.</p>
<p>First, we import the necessary modules
and specify the environment and the discrete system variables and
the continuous dynamics.
Note that we don&#8217;t have to specify the smv file, spc file and aut file
as in the previous examples.</p>
<div class="highlight-rst"><div class="highlight"><pre>from prop2part import Polytope, Region, PropPreservingPartition
from discretizeM import CtsSysDyn, discretizeM
from spec import GRSpec
from rhtlp import SynthesisProb
from numpy import array
from grsim import grsim

env_vars = {&#39;park&#39; : &#39;boolean&#39;}
sys_disc_vars = {&#39;X0reach&#39; : &#39;boolean&#39;}

cont_state_space = Polytope(array([[1., 0.],[-1., 0.], [0., 1.], [0., -1.]]), \
                                   array([[3.],[0.],[2.],[0.]]))

cont_props = {}
for i in xrange(0, 3):
    for j in xrange(0,2):
        prop_sym = &#39;X&#39; + str(3*j + i)
        cont_props[prop_sym] = Polytope(array([[1., 0.],[-1., 0.], [0., 1.], [0., -1.]]), \
                                   array([[float(i+1)],[float(-i)],[float(j+1)],[float(-j)]]))

A = array([[1.1052, 0.],[ 0., 1.1052]])
B = array([[1.1052, 0.],[ 0., 1.1052]])
U = Polytope(array([[1., 0.],[-1., 0.], [0., 1.], [0., -1.]]), array([[1.],[1.],[1.],[1.]]))
sys_dyn = CtsSysDyn(A,B,[],U,[])
</pre></div>
</div>
<p>Next, we specify system specification. Here, specification is a GRSpec object,
instead of a list of length 2 as in the previous examples.</p>
<div class="highlight-rst"><div class="highlight"><pre>spec = GRSpec()
spec.env_prog = &#39;!park&#39;
spec.sys_init = &#39;X0reach&#39;
spec.sys_safety = &#39;next(X0reach) = ((X0 | X0reach) &amp; !park)&#39;
spec.sys_prog = [&#39;X5&#39;, &#39;X0reach&#39;]
</pre></div>
</div>
<p>Now, we have all the necessary elements to construct a synthesis problem.</p>
<div class="highlight-rst"><div class="highlight"><pre>prob = SynthesisProb(env_vars = env_vars, sys_disc_vars = sys_disc_vars, \
                         disc_props = {}, cont_state_space = cont_state_space, \
                         cont_props = cont_props, sys_dyn = sys_dyn, spec=spec, verbose=2)
</pre></div>
</div>
<p>Once a SynthesisProb object is constructed, we can check the realizability of this problem
and construct the automaton.</p>
<div class="highlight-rst"><div class="highlight"><pre>realizability = prob.checkRealizability(verbose=2)

aut = prob.synthesizePlannerAut(verbose=2)
</pre></div>
</div>
<p>Finally, we can run the simulation as before.</p>
<div class="highlight-rst"><div class="highlight"><pre>num_it = 30
init_state = {}
init_state[&#39;X0reach&#39;] = True
env_states = []
for i in xrange(0,num_it):
    if (i%3 == 0):
        env_states.append({&#39;park&#39;:True})
    else:
        env_states.append({&#39;park&#39;:False})

states = grsim(aut, init_state, env_states, num_it)
</pre></div>
</div>
</div>
</div>
<div class="section" id="receding-horizon-temporal-logic-planning">
<h2>Receding Horizon Temporal Logic Planning<a class="headerlink" href="#receding-horizon-temporal-logic-planning" title="Permalink to this headline">¶</a></h2>
<p>For systems with a certain structure, the computational complexity of
the planner synthesis can be alleviated by solving the planning problems
in a receding horizon fashion, i.e., compute the plan or strategy over
a &#8220;shorter&#8221; horizon, starting from the current state,
implement the initial portion of hte plan,
move the horizon one step ahead, and recompute.
This approach essentially reduces the planner synthesis problem
into a set of smaller problems.
To ensure that this &#8220;receding horizon&#8221; framework preserves
the desired system-level temporal properties, certain sufficient conditions
need to be satisfied.</p>
<p>We consider a specification of the form</p>
<div class="math" id="equation-GR1Spec">
<p><span class="eqno">(3)</span><img src="_images/math/f99a25f2f4c2ad8d571bf1ec81e8a67361168e29.png" alt="\varphi = \big(\psi_{init} \wedge \square \psi_e^e \wedge
\bigwedge_{i \in I_f} \square\diamond \psi_{f,i}\big) \implies
\big(\square \psi_s \wedge \bigwedge_{i \in I_g} \psi_{g,i}\big)." /></p>
</div><p>Given a specification of this form, we first construct a finite state abstraction
of the physical system.
Then, for each <img class="math" src="_images/math/7133cd2126dce273512a224f24e5d79236fa1d26.png" alt="i \in I_g"/>, we organize the system states
into a partially ordered set <img class="math" src="_images/math/4c9f4181a17867fddb32003c136042c6cafa147d.png" alt="\mathcal{P}^i = (\{\mathcal{W}_j^i\}, \preceq_{\psi_{g,i}})"/>
where <img class="math" src="_images/math/c6f85e26c6c73d09e21d05728cd6a6c651e78e73.png" alt="\mathcal{W}_0^i"/> are the set of states satisfying
<img class="math" src="_images/math/99d3336099dff9808b8e94e024351a7547b6d948.png" alt="\psi_{g,i}."/>
For each <img class="math" src="_images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j"/>, we define a short-horizon specification <img class="math" src="_images/math/bf7f099a38cb18db2ba01c8519307f02a8542b9b.png" alt="\Psi_j^i"/>
associated with <img class="math" src="_images/math/fe19503db4082446d7af97281052372f8a2d3d15.png" alt="\mathcal{W}_j^i"/> as</p>
<div class="math">
<p><img src="_images/math/ec967d977b6ab0fc2ae01bdb0475e8a99332753f.png" alt="\Psi_j^i = \big((\nu \in \mathcal{W}_j^i) \wedge \Phi \wedge \square \psi_e^e \wedge
\bigwedge_{k \in I_f} \square\diamond \psi_{f,k}\big) \implies
\big(\square \psi_s \wedge \square\diamond(\nu \in \mathcal{F}^i(\mathcal{W}_j^i)) \big)." /></p>
</div><p>Here, <img class="math" src="_images/math/b85bbfb165b853d6f5f9734be4cdabbb453f4e43.png" alt="\Phi"/> describes receding horizon invariants.
<img class="math" src="_images/math/b85bbfb165b853d6f5f9734be4cdabbb453f4e43.png" alt="\Phi"/> needs to be defined such that <img class="math" src="_images/math/c78c09d1290ec46af272c698cb888733b63001fd.png" alt="\psi_{init} \implies \Phi"/> is a tautology.
<img class="math" src="_images/math/02206e2de3fc959e79d4130ad0c1103e76b5c14a.png" alt="\mathcal{F}^i : \{\mathcal{W}_j^i\} \to \{\mathcal{W}_j^i\}"/> is a mapping
such that <img class="math" src="_images/math/362233ed8e53a2ca09d04ff07d1c026e90be3dc9.png" alt="\mathcal{F}^i(\mathcal{W}_j^i) \prec_{\psi_{g,i}} \mathcal{W}_j^i, \forall j \not= 0."/>
<img class="math" src="_images/math/0b1b8525fcc354b8361f82e186cee19744886188.png" alt="\mathcal{F}^i(\mathcal{W}_j^i)"/> essentially defines intermediate goal for starting in
<img class="math" src="_images/math/cd590dd0fa1a1d5f12fc7e7d55fa955a03341162.png" alt="\mathcal{W}^i_j."/></p>
<img alt="_images/rhtlp_strategy.png" src="_images/rhtlp_strategy.png" />
<p>The above figure provides a graphical description of the receding horizon strategy
for a special case where for each
<img class="math" src="_images/math/dfd375f0137d6b078adf2ea151cf38c646bc8099.png" alt="i \in I_g, \mathcal{W}^i_j \prec_{\psi_{g,i}} \mathcal{W}^i_k, \forall j &lt; k"/>,
<img class="math" src="_images/math/073175028887c2a9064bde1c12c13354662ab0f9.png" alt="\mathcal{F}^i(\mathcal{W}^i_j) = \mathcal{W}^i_{j-1}, \forall j &gt; 0"/>
and <img class="math" src="_images/math/6b00d8c0187d425b73c9b7ca5af9e450c1550563.png" alt="F^i(\mathcal{W}^i_0) = \mathcal{W}^i_0."/>
Please refer to our <a class="reference external" href="http://www.cds.caltech.edu/~nok/doc/tac10.pdf">paper</a> for more details.</p>
<div class="section" id="short-horizon-problem">
<h3>Short-Horizon Problem<a class="headerlink" href="#short-horizon-problem" title="Permalink to this headline">¶</a></h3>
<p>A short-horizon problem can be defined using the ShortHorizonProb class.</p>
<blockquote>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">rhtlp.</tt><tt class="descname">ShortHorizonProb</tt><big>(</big><em>W=''</em>, <em>FW=</em><span class="optional">[</span><span class="optional">]</span>, <em>Phi=''</em>, <em>global_prob=&lt;rhtlp.SynthesisProb instance at 0x1027433b0&gt;</em>, <em>**args</em><big>)</big><a class="reference internal" href="_modules/rhtlp.html#ShortHorizonProb"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>ShortHorizonProb class for specifying a short horizon problem for receding horizon 
temporal logic planning.
A ShortHorizonProb object contains the following fields:</p>
<ul class="simple">
<li><cite>W</cite>: a proposition that specifies a set W of states.</li>
<li><cite>FW</cite>: a ShortHorizonProb object or a list of ShortHorizonProb object that specifies 
the set F(W).</li>
<li><cite>Phi</cite>: a proposition that specifies the receding horizon invariant.</li>
<li><cite>global_prob</cite>: a SynthesisProb object that represents the global problem.</li>
</ul>
<p><strong>Constructor</strong>:</p>
<p><strong>ShortHorizonProb</strong> ([ <cite>W</cite> = &#8216;&#8217;[, <cite>FW</cite> = [][, <cite>Phi</cite> = &#8216;&#8217;[, <cite>global_prob</cite> = SynthesisProb()[, 
<cite>file</cite> = &#8216;&#8217;]]]]])</p>
<p><strong>ShortHorizonProb</strong> ([ <cite>W</cite> = &#8216;&#8217;[, <cite>FW</cite> = [][, <cite>Phi</cite> = &#8216;&#8217;[, <cite>global_prob</cite> = SynthesisProb()[, 
<cite>env_vars</cite> = {}[, <cite>sys_disc_vars</cite> = {}[, <cite>disc_props</cite> = {}[, <cite>disc_dynamics</cite> = None]]]]]]]])</p>
<p><strong>ShortHorizonProb</strong> ([ <cite>W</cite> = &#8216;&#8217;[, <cite>FW</cite> = [][, <cite>Phi</cite> = &#8216;&#8217;[, <cite>global_prob</cite> = SynthesisProb()[, 
<cite>env_vars</cite> = {}[, <cite>sys_disc_vars</cite> = {}[, <cite>disc_props</cite> = {}[, <cite>cont_state_space</cite> = None[, 
<cite>cont_props</cite> = {}[, <cite>sys_dyn</cite> = None]]]]]]]]]])</p>
<ul class="simple">
<li><cite>W</cite>: a proposition that specifies a set W of states.</li>
<li><cite>FW</cite>: a ShortHorizonProb object or a list of ShortHorizonProb object that specifies 
the set F(W).</li>
<li><cite>Phi</cite>: a proposition that specifies the receding horizon invariant.</li>
<li><cite>global_spec</cite>: the global specification of the system.</li>
<li><cite>file</cite>: the name of the rhtlp file to be parsed. If <cite>file</cite> is given,
the rest of the inputs to this function will be ignored.</li>
<li><cite>env_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the names 
of environment variables and whose values are their possible values, e.g., 
boolean or {0, 2, ..., 5} or [0, 2, 3, 4, 5].</li>
<li><cite>sys_disc_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the 
names of discrete system variables and whose values are their possible values.</li>
<li><cite>disc_props</cite>: a dictionary {str : str} whose keys are the symbols for 
propositions on discrete variables and whose values are the actual propositions
on discrete variables.</li>
<li><cite>disc_dynamics</cite>: a PropPreservingPartition object that represents the 
transition system obtained from the discretization procedure.
if <cite>disc_dynamics</cite> is given, <cite>cont_state_space</cite>, <cite>cont_props</cite> and <cite>sys_dyn</cite>
will be ignored.</li>
<li><cite>cont_state_space</cite>: a Polytope object that represent the state space of the
continuous variables. Needed only when <cite>discretize</cite> is True.</li>
<li><cite>cont_props</cite>: a dictionary {str : Polytope} whose keys are the symbols for 
propositions on continuous variables and whose values are polytopes that represent
the region in the state space in which the corresponding proposition hold.
if <cite>discretize</cite> is False, <cite>cont_props</cite> can be just a list of symbols for 
propositions on continuous variables.</li>
<li><cite>sys_dyn</cite>: a CtsSysDyn object that specifies the dynamics of the continuous variables.
Needed only when <cite>discretize</cite> is True.</li>
<li><cite>verbose</cite>: an integer that specifies the level of verbosity.</li>
</ul>
</dd></dl>

</blockquote>
</div>
<div class="section" id="receding-horizon-temporal-logic-planning-problem">
<h3>Receding Horizon Temporal Logic Planning Problem<a class="headerlink" href="#receding-horizon-temporal-logic-planning-problem" title="Permalink to this headline">¶</a></h3>
<p>A receding horizon temporal logic planning problem contains a collection of
short-horizon problems. It can be defined using the RHTLPProb class, which
contains many functions such as <tt class="docutils literal"><span class="pre">computePhi()</span></tt> and <tt class="docutils literal"><span class="pre">validate()</span></tt>.</p>
<blockquote>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">rhtlp.</tt><tt class="descname">RHTLPProb</tt><big>(</big><em>shprobs=</em><span class="optional">[</span><span class="optional">]</span>, <em>Phi='True'</em>, <em>discretize=False</em>, <em>**args</em><big>)</big><a class="reference internal" href="_modules/rhtlp.html#RHTLPProb"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>RHTLPProb class for specifying a receding horizon temporal logic planning problem.
A RHTLPProb object contains the following fields:</p>
<ul class="simple">
<li><cite>shprobs</cite>: a list of ShortHorizonProb objects</li>
<li><cite>Phi</cite>: the invariant for the RHTLP problem</li>
</ul>
<p><strong>Constructor</strong>:</p>
<p><strong>RHTLPProb</strong> ([ <cite>shprobs</cite> = [][, <cite>Phi</cite> = &#8216;True&#8217;[, <cite>discretize</cite> = False[, <cite>file</cite> = &#8216;&#8217;]]]]): 
construct this SynthesisProb object from <cite>file</cite>.</p>
<p><strong>RHTLPProb</strong> ([ <cite>shprobs</cite> = [][, <cite>Phi</cite> = &#8216;True&#8217;[, <cite>discretize</cite> = False[, <cite>env_vars</cite> = {}[, `
sys_disc_vars` = {}[, <cite>disc_props</cite> = {}[, <cite>disc_dynamics</cite> = None[, 
<cite>spec</cite> = GRSpec()]]]]]]]])</p>
<p><strong>RHTLPProb</strong> ([ <cite>shprobs</cite> = [][, <cite>Phi</cite> = &#8216;True&#8217;[, <cite>discretize</cite> = False[, <cite>env_vars</cite> = {}[, 
<cite>sys_disc_vars</cite> = {}[, <cite>disc_props</cite> = {}[, <cite>cont_state_space</cite> = None[, 
<cite>cont_props</cite> = {}[, <cite>sys_dyn</cite> = None[, <cite>spec</cite> = GRSpec()]]]]]]])</p>
<ul class="simple">
<li><cite>shprobs</cite>: a list of ShortHorizonProb objects.</li>
<li><cite>Phi</cite>: a string specifying the invariant for the RHTLP problem.</li>
<li><cite>discretize</cite>:  a boolean indicating whether to discretize the global problem.</li>
<li><cite>file</cite>: the name of the rhtlp file to be parsed. If <cite>file</cite> is given,
the rest of the inputs to this function will be ignored.</li>
<li><cite>env_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the names 
of environment variables and whose values are their possible values, e.g., 
boolean or {0, 2, ..., 5} or [0, 2, 3, 4, 5].</li>
<li><cite>sys_disc_vars</cite>: a dictionary {str : str} or {str : list} whose keys are the 
names of discrete system variables and whose values are their possible values.</li>
<li><cite>disc_props</cite>: a dictionary {str : str} whose keys are the symbols for 
propositions on discrete variables and whose values are the actual propositions
on discrete variables.</li>
<li><cite>disc_dynamics</cite>: a PropPreservingPartition object that represents the 
transition system obtained from the discretization procedure.
if <cite>disc_dynamics</cite> is given, <cite>cont_state_space</cite>, <cite>cont_props</cite> and <cite>sys_dyn</cite>
will be ignored.</li>
<li><cite>cont_state_space</cite>: a Polytope object that represent the state space of the
continuous variables. Needed only when <cite>discretize</cite> is True.</li>
<li><cite>cont_props</cite>: a dictionary {str : Polytope} whose keys are the symbols for 
propositions on continuous variables and whose values are polytopes that represent
the region in the state space in which the corresponding proposition hold.
if <cite>discretize</cite> is False, <cite>cont_props</cite> can be just a list of symbols for 
propositions on continuous variables.</li>
<li><cite>sys_dyn</cite>: a CtsSysDyn object that specifies the dynamics of the continuous variables.
Needed only when <cite>discretize</cite> is True.</li>
<li><cite>spec</cite>: a GRSpec object that specifies the specification of this synthesis problem</li>
<li><cite>verbose</cite>: an integer that specifies the level of verbosity.</li>
</ul>
<dl class="method">
<dt>
<tt class="descclassname">RHTLPProb.</tt><tt class="descname">computePhi</tt><big>(</big><em>checktautology=True</em>, <em>verbose=0</em><big>)</big><a class="reference internal" href="_modules/rhtlp.html#RHTLPProb.computePhi"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Compute Phi for this RHTLPProb object.
Return a boolean that indicates whether a valid Phi exists.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">RHTLPProb.</tt><tt class="descname">validate</tt><big>(</big><em>checkcovering=True</em>, <em>excluded_state=</em><span class="optional">[</span><span class="optional">]</span>, <em>checkpartial_order=True</em>, <em>checktautology=True</em>, <em>checkrealizable=True</em>, <em>heap_size='-Xmx128m'</em>, <em>verbose=0</em><big>)</big><a class="reference internal" href="_modules/rhtlp.html#RHTLPProb.validate"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Check whether the list of ShortHorizonProb objects satisfies the sufficient
conditions for receding horizon temporal logic planning</p>
</dd></dl>

</dd></dl>

</blockquote>
</div>
<div class="section" id="example-4-autonomous-vehicle">
<h3>Example 4: Autonomous Vehicle<a class="headerlink" href="#example-4-autonomous-vehicle" title="Permalink to this headline">¶</a></h3>
<p>This example is provided in examples/autonomous_car_road.py.
It is a simplified version of the problem presented in our
<a class="reference external" href="http://www.cds.caltech.edu/~nok/doc/cdc09.pdf">CDC paper</a></p>
<p>We first import the necessary modules.</p>
<div class="highlight-rst"><div class="highlight"><pre>from numpy import array
from polytope_computations import Polytope
from discretizeM import CtsSysDyn
from spec import GRSpec
from rhtlp import RHTLPProb, ShortHorizonProb
import math
</pre></div>
</div>
<p>Specify the road configuration and the problem setup.</p>
<div class="highlight-rst"><div class="highlight"><pre>roadWidth = 3
roadLength = 10
dpopup = 2
dsr = 3
horizon = 3
</pre></div>
</div>
<p>Continuous dynamics.</p>
<div class="highlight-rst"><div class="highlight"><pre>B = array([[1.1052, 0.],[ 0., 1.1052]])
U = Polytope(array([[1., 0.],[-1., 0.], [0., 1.], [0., -1.]]), array([[1.],[1.],[1.],[1.]]))
sys_dyn = CtsSysDyn(A,B,[],U,[])
</pre></div>
</div>
<p>Variables and propositions.</p>
<div class="highlight-rst"><div class="highlight"><pre>env_vars = {}
cont_props = {}
for x in xrange(0, roadLength):
    for y in xrange(0, roadWidth):
        id = str((y*roadLength)+x)
        obs = &#39;obs&#39; + id
        cell = &#39;X&#39; + id
        env_vars[obs] = &#39;boolean&#39;
        cont_props[cell] = Polytope(array([[1., 0.], [-1., 0.], [0., 1.], [0., -1.]]), \
                                        array([[x+1.], [-float(x)], [y+1.], [-float(y)]]))
</pre></div>
</div>
<p>Specification.</p>
<div class="highlight-rst"><div class="highlight"><pre>spec = GRSpec(env_init=&#39;&#39;, sys_init=&#39;&#39;, env_safety=&#39;&#39;, sys_safety=&#39;&#39;, \
                  env_prog=&#39;&#39;, sys_prog=&#39;&#39;)
init_cells = range(0, roadLength*(roadWidth-1)+1, roadLength)

# Assumption on the initial state
for id in xrange(0, roadLength*roadWidth):
    if (not id in init_cells):
        if (len(spec.sys_init) &gt; 0):
            spec.sys_init += &#39; &amp; &#39;
        spec.sys_init += &#39;!X&#39; + str(id)
spec.sys_init = &#39;(&#39; + spec.sys_init + &#39;)&#39;


# If started in the left lane, then there is an obstalce in the right lane.
for x in xrange(0, roadLength):
    cell = &#39;&#39;
    for y in xrange(int(math.floor(roadWidth/2)), roadWidth):
        if (len(cell) &gt; 0):
            cell += &#39; | &#39;
        cell += &#39;X&#39; + str(y*roadLength + x)
    obs = &#39;&#39;
    for obsx in xrange(max([0, x-1]), min([roadLength, x+2])):
        if (len(obs) &gt; 0):
            obs += &#39; | &#39;
        obs += &#39;obs&#39; + str(obsx)
    if (len(spec.sys_init) &gt; 0):
        spec.sys_init += &#39; &amp;\n\t&#39;
    spec.sys_init += &#39;((&#39; + cell + &#39;) -&gt; (&#39; + obs + &#39;))&#39;

for id in init_cells:
    obs = &#39;obs&#39; + str(id)
    cell = &#39;X&#39; + str(id)
    # The robot does not collide with an obstacle
    if (len(spec.sys_init) &gt; 0):
        spec.sys_init += &#39; &amp;\n\t&#39;
    spec.sys_init += &#39;(&#39; + cell + &#39; -&gt; !&#39; + obs + &#39;)&#39;

    # The robot is not surrounded by obstacles
    spec.sys_init += &#39; &amp;\n\t&#39;
    spec.sys_init += &#39;(&#39; + cell + &#39; -&gt; !(&#39; + &#39;obs&#39; + str(id+1) 
    if (math.floor(id/roadLength) &lt; roadWidth - 1):
        spec.sys_init += &#39; &amp; obs&#39; + str(id + roadLength)
    if (math.floor(id/roadLength) &gt; 0):
        spec.sys_init += &#39; &amp; obs&#39; + str(id - roadLength)
    spec.sys_init += &#39;))&#39;

# Assumption on the environment
# Obstacle is always detected before the robot gets too close to it
for x in xrange(0,roadLength):
    cell = &#39;&#39;
    for j in xrange(max([0, x-dpopup]), min([roadLength, x+dpopup+1])):
        for k in xrange(0, roadWidth):
            if (len(cell) &gt; 0):
                cell += &#39; | &#39;
            cell += &#39;X&#39; + str(k*roadLength + j)
    for k in xrange(0, roadWidth):
        obs = &#39;obs&#39; + str(k*roadLength+x)
        if (len(spec.env_safety) &gt; 0):
            spec.env_safety += &#39; &amp;\n\t&#39;
        spec.env_safety += &#39;(((&#39; + cell +&#39;) &amp; !&#39; + obs + &#39;) -&gt; next(!&#39; + obs + &#39;))&#39;

# Sensing range
for x in xrange(0,roadLength):
    cell = &#39;&#39;
    for y in xrange(0,roadWidth):
        if (len(cell) &gt; 0):
            cell += &#39; | &#39;
        cell += &#39;X&#39; + str(y*roadLength + x)
    obs = &#39;&#39;
    for j in xrange(x+dsr, roadLength):
        for k in xrange(0, roadWidth):
            if (len(obs) &gt; 0):
                obs += &#39; &amp; &#39;
            obs += &#39;!obs&#39; + str(k*roadLength + j)
    for j in xrange(0, x-dsr+1):
        for k in xrange(0, roadWidth):
            if (len(obs) &gt; 0):
                obs += &#39; &amp; &#39;
            obs += &#39;!obs&#39; + str(k*roadLength + j)
    if (len(obs) &gt; 0):
        if (len(spec.env_safety) &gt; 0):
            spec.env_safety += &#39; &amp;\n\t&#39;
        spec.env_safety += &#39;((&#39; + cell + &#39;) -&gt; (&#39; + obs + &#39;))&#39;

# The road is not blocked
for i in xrange(0, roadLength):
    for j in xrange(max([0, i-1]), min([i+2, roadLength])):
        for k in xrange(max([0,j-1]), min([j+2,roadLength])):
            if (len(spec.env_safety) &gt; 0):
                spec.env_safety += &#39; &amp;\n\t&#39;
            spec.env_safety += &#39;!(obs&#39; + str(i) + &#39; &amp; obs&#39; + str(roadLength+j) + \
                &#39; &amp; obs&#39; + str(2*roadLength+k) + &#39;)&#39;

for x in xrange(0, roadLength-2):
    if (len(spec.env_safety) &gt; 0):
        spec.env_safety += &#39; &amp;\n\t&#39;
    spec.env_safety += &#39;((obs&#39; + str(roadLength+x) + &#39; &amp; obs&#39; + str(roadLength+x+1) + \
        &#39;) -&gt; (!obs&#39; + str(x+2) + &#39; &amp; !obs&#39; + str(roadLength+x+2) + \
        &#39; &amp; !obs&#39; + str(2*roadLength+x+2) + &#39;))&#39;


# Obstacle does not disappear
for x in xrange(0, roadLength):
    for y in xrange(0, roadWidth):
        obs = &#39;obs&#39; + str((y*roadLength)+x)
        if (len(spec.env_safety) &gt; 0):
            spec.env_safety += &#39; &amp;\n\t&#39;
        spec.env_safety += &#39;(&#39; + obs + &#39; -&gt; next(&#39; + obs + &#39;))&#39;

# Guarantee
# No collision
for x in xrange(0, roadLength):
    for y in xrange(0, roadWidth):
        id = str((y*roadLength)+x)
        obs = &#39;obs&#39; + id
        cell = &#39;X&#39; + id
        if (len(spec.sys_safety) &gt; 0):
            spec.sys_safety += &#39; &amp;\n\t&#39;
        spec.sys_safety += &#39;(&#39; + obs + &#39; -&gt; !&#39; + cell + &#39;)&#39;
        
# Stay in the right lane unless the lane is blocked
for x in xrange(0, roadLength):
    cell = &#39;&#39;
    for y in xrange(int(math.floor(roadWidth/2)), roadWidth):
        if (len(cell) &gt; 0):
            cell += &#39; | &#39;
        cell += &#39;X&#39; + str(y*roadLength + x)
    obs = &#39;&#39;
    for obsx in xrange(max([0, x-1]), min([roadLength, x+2])):
        for obsy in xrange(0, int(math.floor(roadWidth/2)+1)):
            if (len(obs) &gt; 0):
                obs += &#39; | &#39;
            obs += &#39;obs&#39; + str(obsy*roadLength + obsx)
    if (len(spec.sys_safety) &gt; 0):
        spec.sys_safety += &#39; &amp;\n\t&#39;
    spec.sys_safety += &#39;((&#39; + cell + &#39;) -&gt; (&#39; + obs + &#39;))&#39;

# Get to the end of the road
final_cells = range(roadLength-1, roadLength*roadWidth, roadLength)
cell = &#39;&#39;
for fcell in final_cells:
    if (len(cell) &gt; 0):
        cell += &#39; | &#39;
    cell += &#39;X&#39; + str(fcell)
spec.sys_prog = &#39;(&#39; + cell + &#39;)&#39;
</pre></div>
</div>
<p>Now, we construct the RHTLPProb object.</p>
<div class="highlight-rst"><div class="highlight"><pre>rhtlpprob = RHTLPProb(shprobs=[], Phi=&#39;True&#39;, discretize=False, env_vars = env_vars, \
                          sys_disc_vars = {}, disc_props = {}, cont_props = cont_props, \
                          spec = spec)
</pre></div>
</div>
<p>Add ShortHorizonProb objects to the RHTLPProb object.</p>
<div class="highlight-rst"><div class="highlight"><pre>for x_init in xrange(0, roadLength):
    print &#39;adding W&#39; + str(x_init)
    # Environment variables
    env_vars = {}
    for y in xrange(0, roadWidth):
        for x in xrange(x_init, x_init+horizon):
            varname = &#39;obs&#39; + str((y*roadLength)+x)
            env_vars[varname] = &#39;boolean&#39;

    # System continuous variable
    sys_cont_vars = [&#39;x&#39;, &#39;y&#39;]
    cont_state_space = Polytope(array([[1., 0.], [-1., 0.], [0., 1.], [0., -1.]]), \
                                    array([[float(min([x_init+horizon, roadLength]))], \
                                               [float(-x_init)], \
                                               [float(roadWidth)], \
                                               [0.]]))

    # W
    initCells = range(x_init, x_init+roadLength*(roadWidth-1)+1, roadLength)
    W = &#39;&#39;
    for i in initCells:
        if (len(W) &gt; 0):
            W += &#39; | &#39;
        W += &#39;X&#39; + str(i)
    print W

    # Phi
    Phi = &#39;&#39;
    for id in initCells:
        obs = &#39;obs&#39; + str(id)
        cell = &#39;X&#39; + str(id)
        # The robot does not collide with an obstacle
        if (len(Phi) &gt; 0):
            Phi += &#39; &amp;\n\t&#39;
        Phi += &#39;(&#39; + cell + &#39; -&gt; !&#39; + obs + &#39;)&#39;

        # The robot is not surrounded by obstacles
        if (id % roadLength &lt; roadLength-1):
            Phi += &#39; &amp;\n\t&#39;
            Phi += &#39;(&#39; + cell + &#39; -&gt; !(&#39; + &#39;obs&#39; + str(id+1) 
            if (math.floor(id/roadLength) &lt; roadWidth - 1):
                Phi += &#39; &amp; obs&#39; + str(id + roadLength)
            if (math.floor(id/roadLength) &gt; 0):
                Phi += &#39; &amp; obs&#39; + str(id - roadLength)
            Phi += &#39;))&#39;

        # If started in the left lane, then there is an obstalce in the right lane.
        if (math.floor(id/roadLength) &gt;= math.floor(roadWidth/2)):
            Phi += &#39; &amp;\n\t&#39;
            obs = &#39;&#39;
            x = id % roadLength
            for obsx in xrange(max([0, x-1]), min([roadLength, x+2])):
                for obsy in xrange(0, int(math.floor(roadWidth/2)+1)):
                    if (len(obs) &gt; 0):
                        obs += &#39; | &#39;
                    obs += &#39;obs&#39; + str(obsy*roadLength + obsx)
            Phi += &#39;(&#39; + cell + &#39; -&gt; (&#39; + obs + &#39;))&#39;

    rhtlpprob.addSHProb(ShortHorizonProb(W=W, FW=[], Phi=Phi, \
                                             global_prob = rhtlpprob, \
                                             env_vars = env_vars, \
                                             sys_disc_vars = {}, \
                                             disc_props = {}, \
                                             cont_state_space=cont_state_space, \
                                             cont_props = cont_props, \
                                             sys_dyn = sys_dyn))
</pre></div>
</div>
<p>For each <img class="math" src="_images/math/d8cbac6cf1bf28b91dd620985e31374ce3a175d6.png" alt="\mathcal{W}_j"/>, set <img class="math" src="_images/math/5121796e6cf69f138d168b2dc14866f821b7c1b4.png" alt="\mathcal{F}(\mathcal{W}_j)."/></p>
<div class="highlight-rst"><div class="highlight"><pre>for x_init in xrange(0, roadLength):
    FWind = min([roadLength-1, x_init+horizon-1])
    rhtlpprob.shprobs[x_init].setFW(FW=rhtlpprob.shprobs[FWind], update=True, verbose=3)
</pre></div>
</div>
<p>Now, we can validate whether the RHTLPProb object satisfies all the sufficient conditions.</p>
<div class="highlight-rst"><div class="highlight"><pre>ret = rhtlpprob.validate()
</pre></div>
</div>
<p>The result of the above <tt class="docutils literal"><span class="pre">validate()</span></tt> call is that the state in which
<img class="math" src="_images/math/bc120c055696ee99a2a18d7687150353f2e1af65.png" alt="X_i = 0, \forall i \in \{0, \ldots, 29\}"/> is not in any <img class="math" src="_images/math/98b3bcf884f5434039672f8962a595b93577044b.png" alt="\mathcal{W}_j,"/>
i.e., the sufficient condition that the union of all <img class="math" src="_images/math/d8cbac6cf1bf28b91dd620985e31374ce3a175d6.png" alt="\mathcal{W}_j"/>
covers the entire state space is not satisfied.
Since we know that we don&#8217;t have to deal with the above state, we will exclude it.</p>
<div class="highlight-rst"><div class="highlight"><pre>excluded_state = {}
for id in xrange(0, roadLength*roadWidth):
    excluded_state[&#39;X&#39;+str(id)] = False

ret = rhtlpprob.validate(excluded_state=excluded_state)
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial and Examples</a><ul>
<li><a class="reference internal" href="#synthesis-of-embedded-control-systems">Synthesis of Embedded Control Systems</a><ul>
<li><a class="reference internal" href="#proposition-preserving-partition-of-continuous-state-space">Proposition Preserving Partition of Continuous State Space</a></li>
<li><a class="reference internal" href="#continuous-state-space-discretization">Continuous State Space Discretization</a></li>
<li><a class="reference internal" href="#digital-design-synthesis">Digital design synthesis</a></li>
<li><a class="reference internal" href="#example-1-robot-motion-planning-with-only-discrete-decisions">Example 1: Robot Motion Planning with only Discrete Decisions</a></li>
<li><a class="reference internal" href="#example-2-robot-motion-planning">Example 2: Robot Motion Planning</a></li>
<li><a class="reference internal" href="#defining-a-synthesis-problem">Defining a Synthesis Problem</a></li>
<li><a class="reference internal" href="#example-3-robot-motion-planning-using-synthesisprob">Example 3: Robot Motion Planning using SynthesisProb</a></li>
</ul>
</li>
<li><a class="reference internal" href="#receding-horizon-temporal-logic-planning">Receding Horizon Temporal Logic Planning</a><ul>
<li><a class="reference internal" href="#short-horizon-problem">Short-Horizon Problem</a></li>
<li><a class="reference internal" href="#receding-horizon-temporal-logic-planning-problem">Receding Horizon Temporal Logic Planning Problem</a></li>
<li><a class="reference internal" href="#example-4-autonomous-vehicle">Example 4: Autonomous Vehicle</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="intro.html"
                        title="previous chapter">Introduction</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="rhtlp.html"
                        title="next chapter">Receding horizon Temporal Logic Planning</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rhtlp.html" title="Receding horizon Temporal Logic Planning"
             >next</a> |</li>
        <li class="right" >
          <a href="intro.html" title="Introduction"
             >previous</a> |</li>
        <li><a href="index.html">rhtlp v0.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Richard Murray, Necmiye Ozay, Ufuk Topcu, Nok Wongpiromsarn, Mumu Xu.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>